// Copyright 2024 Open Source Robotics Foundation, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// File generated by gen_ros_casters.py. Do not manually change.

#ifndef IMAGE_TRANSPORT_PY__CAST_IMAGE_HPP_
#define IMAGE_TRANSPORT_PY__CAST_IMAGE_HPP_

#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#include "pybind11/operators.h"
#include "pybind11/pybind11.h"
#include "pybind11/stl.h"

#include "sensor_msgs/msg/image.hpp"
#include "sensor_msgs/msg/camera_info.hpp"

#if PYBIND11_VERSION_MAJOR > 2 || (PYBIND11_VERSION_MAJOR == 2 && PYBIND11_VERSION_MINOR >= 9)
    #define const_name _
#endif

static inline bool is_ros_msg_type(pybind11::handle src, const std::string & msg_type_name)
{
  return pybind11::hasattr(src, "__module__") &&
         src.attr("__module__").cast<std::string>() == msg_type_name;
}

namespace pybind11
{
namespace detail
{

using ContainerAllocator = std::allocator<void>;

template<>
struct type_caster<builtin_interfaces::msg::Time_<ContainerAllocator>>
{
public:
  PYBIND11_TYPE_CASTER(
    builtin_interfaces::msg::Time_<ContainerAllocator>,
    const_name("builtin_interfaces::msg::Time_<ContainerAllocator>"));
  bool load(handle src, bool)
  {
    if (!is_ros_msg_type(src, "builtin_interfaces.msg._time")) {
      return false;
    }
    value.sec = src.attr("sec").cast<int32_t>();
    value.nanosec = src.attr("nanosec").cast<uint32_t>();
    return true;
  }

  static handle cast(
    builtin_interfaces::msg::Time_<ContainerAllocator> cpp_msg, return_value_policy /* policy */,
    handle /* parent */)
  {
    object mod = module::import("builtin_interfaces.msg._time");
    object MsgType = mod.attr("Time");
    object msg = MsgType();
    msg.attr("sec") = pybind11::cast(cpp_msg.sec);
    msg.attr("nanosec") = pybind11::cast(cpp_msg.nanosec);
    msg.inc_ref();
    return msg;
  }
};

template<>
struct type_caster<std_msgs::msg::Header_<ContainerAllocator>>
{
public:
  PYBIND11_TYPE_CASTER(
    std_msgs::msg::Header_<ContainerAllocator>,
    const_name("std_msgs::msg::Header_<ContainerAllocator>"));
  bool load(handle src, bool)
  {
    if (!is_ros_msg_type(src, "std_msgs.msg._header")) {
      return false;
    }
    value.stamp = src.attr("stamp").cast<builtin_interfaces::msg::Time_<ContainerAllocator>>();
    value.frame_id =
      src.attr("frame_id")
      .cast<std::basic_string<
          char, std::char_traits<char>,
          typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>();
    return true;
  }

  static handle cast(
    std_msgs::msg::Header_<ContainerAllocator> cpp_msg, return_value_policy /* policy */,
    handle /* parent */)
  {
    object mod = module::import("std_msgs.msg._header");
    object MsgType = mod.attr("Header");
    object msg = MsgType();
    msg.attr("stamp") = pybind11::cast(cpp_msg.stamp);
    msg.attr("frame_id") = pybind11::cast(cpp_msg.frame_id);
    msg.inc_ref();
    return msg;
  }
};

template<>
struct type_caster<sensor_msgs::msg::Image_<ContainerAllocator>>
{
public:
  PYBIND11_TYPE_CASTER(
    sensor_msgs::msg::Image_<ContainerAllocator>,
    const_name("sensor_msgs::msg::Image_<ContainerAllocator>"));
  bool load(handle src, bool)
  {
    if (!is_ros_msg_type(src, "sensor_msgs.msg._image")) {
      return false;
    }
    value.header = src.attr("header").cast<std_msgs::msg::Header_<ContainerAllocator>>();
    value.height = src.attr("height").cast<uint32_t>();
    value.width = src.attr("width").cast<uint32_t>();
    value.encoding =
      src.attr("encoding")
      .cast<std::basic_string<
          char, std::char_traits<char>,
          typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>();
    value.is_bigendian = src.attr("is_bigendian").cast<uint8_t>();
    value.step = src.attr("step").cast<uint32_t>();
    value.data =
      src.attr("data")
      .cast<std::vector<
          uint8_t,
          typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>>>();
    return true;
  }

  static handle cast(
    sensor_msgs::msg::Image_<ContainerAllocator> cpp_msg, return_value_policy /* policy */,
    handle /* parent */)
  {
    object mod = module::import("sensor_msgs.msg._image");
    object MsgType = mod.attr("Image");
    object msg = MsgType();
    msg.attr("header") = pybind11::cast(cpp_msg.header);
    msg.attr("height") = pybind11::cast(cpp_msg.height);
    msg.attr("width") = pybind11::cast(cpp_msg.width);
    msg.attr("encoding") = pybind11::cast(cpp_msg.encoding);
    msg.attr("is_bigendian") = pybind11::cast(cpp_msg.is_bigendian);
    msg.attr("step") = pybind11::cast(cpp_msg.step);
    msg.attr("data") = pybind11::cast(cpp_msg.data);
    msg.inc_ref();
    return msg;
  }
};

template<>
struct type_caster<std::shared_ptr<const sensor_msgs::msg::Image>>
{
public:
  PYBIND11_TYPE_CASTER(
    std::shared_ptr<const sensor_msgs::msg::Image>,
    const_name("sensor_msgs::msg::Image"));

  bool load(handle src, bool)
  {
    type_caster<sensor_msgs::msg::Image> base_caster;
    if (!base_caster.load(src, false)) {
      return false;
    }
    value =
      std::make_shared<sensor_msgs::msg::Image>(
      std::move(
        base_caster.operator sensor_msgs::msg
        ::Image & ()));
    return true;
  }

  static handle cast(
    const std::shared_ptr<const sensor_msgs::msg::Image> & ptr,
    return_value_policy policy, handle parent)
  {
    if (!ptr) {
      return pybind11::none().release();
    }
    return type_caster<sensor_msgs::msg::Image>::cast(*ptr, policy, parent);
  }
};

template<>
struct type_caster<sensor_msgs::msg::RegionOfInterest_<ContainerAllocator>>
{
public:
  PYBIND11_TYPE_CASTER(
    sensor_msgs::msg::RegionOfInterest_<ContainerAllocator>,
    const_name("sensor_msgs::msg::RegionOfInterest_<ContainerAllocator>"));
  bool load(handle src, bool)
  {
    if (!is_ros_msg_type(src, "sensor_msgs.msg._region_of_interest")) {
      return false;
    }
    value.x_offset = src.attr("x_offset").cast<uint32_t>();
    value.y_offset = src.attr("y_offset").cast<uint32_t>();
    value.height = src.attr("height").cast<uint32_t>();
    value.width = src.attr("width").cast<uint32_t>();
    value.do_rectify = src.attr("do_rectify").cast<bool>();
    return true;
  }

  static handle cast(
    sensor_msgs::msg::RegionOfInterest_<ContainerAllocator> cpp_msg,
    return_value_policy /* policy */,
    handle /* parent */)
  {
    object mod = module::import("sensor_msgs.msg._region_of_interest");
    object MsgType = mod.attr("RegionOfInterest");
    object msg = MsgType();
    msg.attr("x_offset") = pybind11::cast(cpp_msg.x_offset);
    msg.attr("y_offset") = pybind11::cast(cpp_msg.y_offset);
    msg.attr("height") = pybind11::cast(cpp_msg.height);
    msg.attr("width") = pybind11::cast(cpp_msg.width);
    msg.attr("do_rectify") = pybind11::cast(cpp_msg.do_rectify);
    msg.inc_ref();
    return msg;
  }
};

template<>
struct type_caster<sensor_msgs::msg::CameraInfo_<ContainerAllocator>>
{
public:
  PYBIND11_TYPE_CASTER(
    sensor_msgs::msg::CameraInfo_<ContainerAllocator>,
    const_name("sensor_msgs::msg::CameraInfo_<ContainerAllocator>"));
  bool load(handle src, bool)
  {
    if (!is_ros_msg_type(src, "sensor_msgs.msg._camera_info")) {
      return false;
    }
    value.header = src.attr("header").cast<std_msgs::msg::Header_<ContainerAllocator>>();
    value.height = src.attr("height").cast<uint32_t>();
    value.width = src.attr("width").cast<uint32_t>();
    value.distortion_model = src.attr("distortion_model").cast<std::basic_string<char,
        std::char_traits<char>,
        typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>();
    value.d = src.attr("d").cast<std::vector<double,
        typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>>>();
    value.k = src.attr("k").cast<std::array<double, 9>>();
    value.r = src.attr("r").cast<std::array<double, 9>>();
    value.p = src.attr("p").cast<std::array<double, 12>>();
    value.binning_x = src.attr("binning_x").cast<uint32_t>();
    value.binning_y = src.attr("binning_y").cast<uint32_t>();
    value.roi = src.attr("roi").cast<sensor_msgs::msg::RegionOfInterest_<ContainerAllocator>>();
    return true;
  }

  static handle cast(
    sensor_msgs::msg::CameraInfo_<ContainerAllocator> cpp_msg,
    return_value_policy /* policy */,
    handle /* parent */)
  {
    object mod = module::import("sensor_msgs.msg._camera_info");
    object MsgType = mod.attr("CameraInfo");
    object msg = MsgType();
    msg.attr("header") = pybind11::cast(cpp_msg.header);
    msg.attr("height") = pybind11::cast(cpp_msg.height);
    msg.attr("width") = pybind11::cast(cpp_msg.width);
    msg.attr("distortion_model") = pybind11::cast(cpp_msg.distortion_model);
    msg.attr("d") = pybind11::cast(cpp_msg.d);
    msg.attr("k") = pybind11::cast(cpp_msg.k);
    msg.attr("r") = pybind11::cast(cpp_msg.r);
    msg.attr("p") = pybind11::cast(cpp_msg.p);
    msg.attr("binning_x") = pybind11::cast(cpp_msg.binning_x);
    msg.attr("binning_y") = pybind11::cast(cpp_msg.binning_y);
    msg.attr("roi") = pybind11::cast(cpp_msg.roi);
    msg.inc_ref();
    return msg;
  }
};

template<>
struct type_caster<std::shared_ptr<const sensor_msgs::msg::CameraInfo>>
{
public:
  PYBIND11_TYPE_CASTER(
    std::shared_ptr<const sensor_msgs::msg::CameraInfo>,
    const_name("sensor_msgs::msg::CameraInfo"));

  bool load(handle src, bool)
  {
    type_caster<sensor_msgs::msg::CameraInfo> base_caster;
    if (!base_caster.load(src, false)) {
      return false;
    }
    value =
      std::make_shared<sensor_msgs::msg::CameraInfo>(
      std::move(
        base_caster.operator sensor_msgs
        ::msg::CameraInfo & ()));
    return true;
  }

  static handle cast(
    const std::shared_ptr<const sensor_msgs::msg::CameraInfo> & ptr,
    return_value_policy policy, handle parent)
  {
    if (!ptr) {
      return pybind11::none().release();
    }
    return type_caster<sensor_msgs::msg::CameraInfo>::cast(*ptr, policy, parent);
  }
};

}  // namespace detail
}  // namespace pybind11

#endif  // IMAGE_TRANSPORT_PY__CAST_IMAGE_HPP_
