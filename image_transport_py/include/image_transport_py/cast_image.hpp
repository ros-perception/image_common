// Copyright 2023 Open Source Robotics Foundation, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// File generated by gen_ros_casters.py. Do not manually change.

#ifndef IMAGE_TRANSPORT_PY__CAST_IMAGE_HPP_
#define IMAGE_TRANSPORT_PY__CAST_IMAGE_HPP_

#include <memory>
#include <string>
#include <vector>

#include "pybind11/operators.h"
#include "pybind11/pybind11.h"
#include "pybind11/stl.h"

#include "sensor_msgs/msg/image.hpp"

static inline bool is_ros_msg_type(pybind11::handle src, const std::string & msg_type_name)
{
  return pybind11::hasattr(src, "__module__") &&
         src.attr("__module__").cast<std::string>() == msg_type_name;
}

namespace pybind11
{
namespace detail
{

using ContainerAllocator = std::allocator<void>;

template<>
struct type_caster<builtin_interfaces::msg::Time_<ContainerAllocator>>
{
public:
  PYBIND11_TYPE_CASTER(
    builtin_interfaces::msg::Time_<ContainerAllocator>,
    const_name("builtin_interfaces::msg::Time_<ContainerAllocator>"));
  bool load(handle src, bool)
  {
    if (!is_ros_msg_type(src, "builtin_interfaces.msg._time")) {
      return false;
    }
    value.sec = src.attr("sec").cast<int32_t>();
    value.nanosec = src.attr("nanosec").cast<uint32_t>();
    return true;
  }

  static handle cast(
    builtin_interfaces::msg::Time_<ContainerAllocator> cpp_msg, return_value_policy /* policy */,
    handle /* parent */)
  {
    object mod = module::import("builtin_interfaces.msg._time");
    object MsgType = mod.attr("Time");
    object msg = MsgType();
    msg.attr("sec") = pybind11::cast(cpp_msg.sec);
    msg.attr("nanosec") = pybind11::cast(cpp_msg.nanosec);
    msg.inc_ref();
    return msg;
  }
};

template<>
struct type_caster<std_msgs::msg::Header_<ContainerAllocator>>
{
public:
  PYBIND11_TYPE_CASTER(
    std_msgs::msg::Header_<ContainerAllocator>,
    const_name("std_msgs::msg::Header_<ContainerAllocator>"));
  bool load(handle src, bool)
  {
    if (!is_ros_msg_type(src, "std_msgs.msg._header")) {
      return false;
    }
    value.stamp = src.attr("stamp").cast<builtin_interfaces::msg::Time_<ContainerAllocator>>();
    value.frame_id =
      src.attr("frame_id")
      .cast<std::basic_string<
          char, std::char_traits<char>,
          typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>();
    return true;
  }

  static handle cast(
    std_msgs::msg::Header_<ContainerAllocator> cpp_msg, return_value_policy /* policy */,
    handle /* parent */)
  {
    object mod = module::import("std_msgs.msg._header");
    object MsgType = mod.attr("Header");
    object msg = MsgType();
    msg.attr("stamp") = pybind11::cast(cpp_msg.stamp);
    msg.attr("frame_id") = pybind11::cast(cpp_msg.frame_id);
    msg.inc_ref();
    return msg;
  }
};

template<>
struct type_caster<sensor_msgs::msg::Image_<ContainerAllocator>>
{
public:
  PYBIND11_TYPE_CASTER(
    sensor_msgs::msg::Image_<ContainerAllocator>,
    const_name("sensor_msgs::msg::Image_<ContainerAllocator>"));
  bool load(handle src, bool)
  {
    if (!is_ros_msg_type(src, "sensor_msgs.msg._image")) {
      return false;
    }
    value.header = src.attr("header").cast<std_msgs::msg::Header_<ContainerAllocator>>();
    value.height = src.attr("height").cast<uint32_t>();
    value.width = src.attr("width").cast<uint32_t>();
    value.encoding =
      src.attr("encoding")
      .cast<std::basic_string<
          char, std::char_traits<char>,
          typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>();
    value.is_bigendian = src.attr("is_bigendian").cast<uint8_t>();
    value.step = src.attr("step").cast<uint32_t>();
    value.data =
      src.attr("data")
      .cast<std::vector<
          uint8_t,
          typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>>>();
    return true;
  }

  static handle cast(
    sensor_msgs::msg::Image_<ContainerAllocator> cpp_msg, return_value_policy /* policy */,
    handle /* parent */)
  {
    object mod = module::import("sensor_msgs.msg._image");
    object MsgType = mod.attr("Image");
    object msg = MsgType();
    msg.attr("header") = pybind11::cast(cpp_msg.header);
    msg.attr("height") = pybind11::cast(cpp_msg.height);
    msg.attr("width") = pybind11::cast(cpp_msg.width);
    msg.attr("encoding") = pybind11::cast(cpp_msg.encoding);
    msg.attr("is_bigendian") = pybind11::cast(cpp_msg.is_bigendian);
    msg.attr("step") = pybind11::cast(cpp_msg.step);
    msg.attr("data") = pybind11::cast(cpp_msg.data);
    msg.inc_ref();
    return msg;
  }
};

}  // namespace detail
}  // namespace pybind11

#endif  // IMAGE_TRANSPORT_PY__CAST_IMAGE_HPP_
